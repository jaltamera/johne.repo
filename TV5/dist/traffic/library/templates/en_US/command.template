/**
GENERAL
-------

This template is used to model commands or transactions that can be performed on objects in the system. 

By default the template matches Search commands implicitly (when the keyword is not present 
in the input). You can change that by setting the implicitMatch property to false. 


SUPPORTED FEATURES
------------------
The template supports IMPLICIT_MATCHING, PREFERENCE, TYPE, AMBIGUITY, JOIN, GUESS (variables), CONTEXT LOOKUP, KEYWORD_ONLY_MATCH and
RECENCY.

If IMPLICIT_MATCHING is supported then the agent will make a claim on the input even if the command keyword 
(and its synonyms) wont appear in the input.

PREFERENCE is an xml attribute that will be associated to the actuation of the agent. The preference value 
can be examined outside the agent network to resolve ambiguities. For example the input "san francisco" can  cause an 
ambiguity between Find and a Map commands. The agent network will report the ambiguity. But the IO mode can
examine the preference attribute associted with the XML generated by Find and Map to decide which of Find or Map 
has the preference. For example Find may have a higher preference than Map and so the system can carry out the Find
command but also give a hint on the ambiguity occured so the user could disambiguate (e.g. by saying "map it").

TYPE is an xml attribute which defines the role of this template. The type attribute of this template is 'command' (do not change the value of this attribute).

If AMBIGUITY is supported then ambiguoities are detected and ambiguous actuations are generated.

If JOIN is not supported then each claim made by this agent will include at most one instance of each  
searhable command. If JOIN is supported then claims can include multiple instances of each command. JOIN uses 
the orKeywrod and AndKeyword (both are template properties) to recognize different type of joins. 
For example a find command on an appointment and an OR of two contacts and an OR of 3 tasks will look like:
<Find>
  <Appointment>...</Appointment>
  <Contact>...</Contact>
  <Contact>...</Contact>
  <Task>...</Task>
  <Task>...</Task>
  <Task>...</Task>
</Find>

If GUESS is supported then variables will be used to guess what the user is searching for. This is mostly useful
for out of scope commands where the searchable object is not recognized. Support for guess can help in giving a 
proper response for out of scope search commands (such as performing an open ended search on the web).

If CONTEXT LOOKUP is supported then the context will be used by the agent as a data source.
In this case the agent will use all elements with the agent's xml tag as data source.
For example assume that the following is part of the previous action of a Context:
  <Find>
      <![CDATA[book]]>
  </Find>
  <Find>    
    <Name>
      <![CDATA[Pegah]]>
    </Name>
  </Find>
Then a Find agent will use 'book'  data and will try to match those to
the input. This is useful for claiming what has been guessed using the variable condition by 
this agent on a previous input. 

Currently the CONTEXT LOOKUP support is only for the previous action of the context.

If KEYWORD_ONLY_MATCH is supported then the agent will make a claim if a keyword identifying this command is matched 
but no objects is specified for the command.

If RECENCY is supported the down chain agents that have been actuated more recently will be
given higher priority. The recency of actuation is determined by examining the previous actuation 
in the context (tags in the previous actuation relative to the down chain of this agent - the tags 
should appear right Under a tag made by this agent). 

INTERPRETATION
--------------
By default more priority is given on claims made on a single command rather than claims joining multipe commands. 
For example consider a calendar application with Contacts, Tasks and Appointments. Where "lunch" is both the subject
of a meeting and a name of a task and "John" is a Contact name. The input "find lunch meeting" will be claimed by 
Appointment and also by a claim joining Tasks and Contacts. In this case we want to give higher priority to Appointment.

Also more recently mentioned commands will have more priority. So for example if the user asks for
"appointment with john" and then asks for "..david" it will be assumed that 'david' is a reference to an appointment
(rather than contact name or email receipient) as appointment has been mentioned in the previous input.
*/

/** What is the keyword that identifies this command? */
String keyword = this.tag;

/** What is the priority associated with this command... priorities can be examined outside the agent network
    to resolve ambiguities */
String preference;

/** What is the role of this template/agent? This is going to be used as an XML attribute associated to the XML element created by this template*/
constant String type = 'command';

/** These flags are used to set or reset certain features in the polcies created by this template*/

/** Should the policies support implicit matches? that is when an object is referenced in the input but this command
    is not referenced (eg. users say 'dontact john' instead of 'find contact john'). */
Boolean implicitMatch = true;
/** Should the agent make a claim if a keyword is matched but no object is matched? */
Boolean supportKeywordOnlyMatch = true;
/** Should the policies support ambiguity? */
Boolean supportAmbiguity = true;
/** Should the agent use the context as a data source?  */
Boolean supportContextLookup = true;
/** Should the polcies referring to recently referenced actions get higher priority? */
Boolean supportRecency = true;
/** Should variables be used to guess the object of this command? */
Boolean supportGuess = false;
/** Should the policies support joining commands to eachother? (ORs and ANDs)*/
Boolean supportJoin = true;
/** The condition used to identify an OR join*/
Condition orKeyword = 'or';
/** The condition used to identify an AND join*/
Condition andKeyword = 'and';
/* What is the minimum number of tokens that should be used as a variable.<br> Used only if supportGuess is true */
Integer minVariableSize = 1; 
/* What is the maximum number of tokens that should be used as a variable.<br> Used only if supportGuess is true */
Integer maxVariableSize = 3; 
/* What is the minimum size of a non-noise token (in characters).<br> Noise tokens will not be claimed as part of a variable.<br> Used only if supportGuess is true */
Integer minVariableNonNoiseTokenSize = 1; 
/* What is the file used to list noise words. Noise words will not be claimed as part of a variable. <br>Used only if supportGuess is true */
File variableNoiseFile = 'variable_noise.txt'; 

/** The condition used to match explicit claims on the command this agent is representing.<br>
    Should be a combination of any string literal, kwd and theReference
  */
Condition equalsTo = kwd;

/** Should the agent filter unvaluable (potentially problematic) down chain agent claims?
  */
Boolean enableFilterDownChainClaims = true;

/** Should the agent filter non field down chain agent claims?
  */
Boolean enableFilterDownChainClaimsWithMoreRelations = true;

/** Should the agent filter down chain agent claims that are a subset of other downchain claims?
  */
Boolean enableFilterSubsetDownChainClaims = true;

/** How should the value of this field be used to narrow down the previous input? <br>
    Valid values are: <i>add</i>, <i>addNew</i> and <i>replace</i> <br>
    If replace (which is the default if no values is associated with this property) then the 
    the old relation value will be removed when new relation value is added.<br>
    If add then the new relation value will be added along with the old relation value.<br>
    If addNew then a new command will be added and this relation will be part of the relation referenced in the new command (old command will be kept in the output as well)<p>

    Example:<br>
    for a pizza object the size and crust fields can be seen as fields that should always be replaced on followup (replace).<br>
    for example: <br>
    "small pizza"<br>
    "..large pizza"<br>
    you don't want to end up with a pizza which is both small and large<p>

    However you may decide that new toppings should always be added to old toppigs when you followup (add):<br>
    for example:<br>
    "pepperoni pizza"<br>
    "..ham"<br>
    you want to end up with a "pepperoni and ham pizza"<p>

    Then you may decide that the count for a pizza always means that a new order is coming (addNew):<br>
    "1 pepperoni pizza"<br>
    "..2 small ones"<br>
    "..and one large pizza"<br>
    in this case you want to end up with three orders for 5 pizzas (1 pepperoni, 2 small and one large)
*/    
String defaultSlotFilling;

/**
    By default this is not a single slot. But you can set this to true.
*/
Boolean singleSlot;



/** Claims keywords used for this command */
kwd:
    this.keyword | /CONTEXT:KWD(this.tag)
    {attributes: 'private, atomic'}
    {action: addAttribute('explicit', 'true')}
;

/** Actuated when the user references this command without referencing any objects.
    Makes a claim only if either supportKeywordOnlyMatch is true or if this agent is part of a previous ambiguity.
*/
onlyKwd:
    this.supportKeywordOnlyMatch & kwd  | <check('previous_ambiguity', this)> & kwd
    {attributes: 'private, atomic'}
    {priority: topicScope(this, this.supportRecency)}
    {action: com.dejima.core.nlp.text.action.CommandActuation: 
        setTag(this.tag), addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), kwd}
;

/** want to give high priority to a topic, if any. If its not a topic, then recency is used, which 
 *  gives priority to recently discussed items  */
topic(this.children):
    this.children[.]
    {attributes: 'private'}
    {priority: topicScope(this.children[.], this.supportRecency)}
    {action: this.children[.]}
;

object(this.children):
    topic(this.children[.]) | this.supportAmbiguity & (<mergeIfAmbiguous(topic(this.children[.]),topic(this.children[#]):op(,))>)
    {attributes: 'private'}
    {ambiguity action: com.dejima.core.nlp.text.action.EntityActuation:  
       setTag(this.ambiguityTag), topic(this.children)}
;

objects:
    <merge(object(this.children):op(,))>
    {attributes: 'private'}
    {action: object(this.children)}
;

/** Claims on the context */
contextMatch:
    (this.supportContextLookup & /CONTEXT (this.tag))
    {attributes: 'private, atomic'}
    {action: addCData(*.matched)}
;

value:
    objects | contextMatch
    {attributes: 'private'}
;

equalsTo:
    this.equalsTo
    {attributes: 'private, atomic'}
;


/** This policy makes claims if the input explicitly refers to this seach command (search keywords are used in the input) */
certainlyExplicit:
    equalsTo ~ value
    {attributes: 'private, atomic'}
    {priority: 10001}
    {action: equalsTo, value}
;

maybeExplicit:
    equalsTo & value
    {attributes: 'private'}
    {action: equalsTo, value}
;

explicit: 
   certainlyExplicit | maybeExplicit
   {attributes: 'private'}
;

/** This policy makes claims if implicit matching is supported */
implicit:
    (this.implicitMatch|<check('previous_action',this)>) & value
    {attributes: 'private'}
;

/** Makes a guess on the value of what is to be searched (if the guess feature is supported) */
containsGuess:
    this.supportGuess & kwd ?:(this.minVariableSize,this.maxVariableSize):this.minVariableNonNoiseTokenSize:this.variableNoiseFile
    {attributes: 'private, atomic'}
    {action: kwd, addCData(?)}
;

variableInQuotes:
    this.supportGuess & (('\'' ? '\'') | ('"' ? '"'))
    {attributes: 'private, atomic'}
    {action: '"',?,'"'}
;

/** Makes a guess on the exact value of the searchable item (if the guess feature is supported). 
    The guess will be made only on words surrounded by quotes.
  */
exactGuess:
    this.supportGuess & (kwd ~ variableInQuotes)
    {attributes: 'private, atomic'}
    {action: kwd, addCData(variableInQuotes)}
;

/** only make a guess if there are no explicit matches
  */
guess:
    this.supportGuess & ([''] - <exists> explicit) & (containsGuess | exactGuess)
    {attributes: 'private, atomic'}
;

aCommand:
    explicit | implicit | guess
    {attributes: 'private'}
;

command:
    aCommand
    {attributes: 'private'}
    {action: com.dejima.core.nlp.text.action.CommandActuation: 
        setTag(this.tag), addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), aCommand}
;

andJoin:
    this.andKeyword
    {attributes: 'private, atomic'}
    {action:  
       addAttribute('join', 'and')}
;

orJoin:
    this.orKeyword
    {attributes: 'private, atomic'}
    {action:  
       addAttribute('join', 'or')}
;

joinOperation:
    orJoin | andJoin
    {attributes: 'private, atomic'}
;

joinedCommand:
    this.supportJoin & (joinOperation ~ aCommand)
    {attributes: 'private'}
    {action: com.dejima.core.nlp.text.action.CommandActuation: 
        setTag(this.tag), addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), joinOperation, aCommand}
;

joinedCommands:
    this.supportJoin & (command &^ joinedCommand)
    {attributes: 'private'}
;

main:
   (onlyKwd | joinedCommands | command)+
   {action: onlyKwd, joinedCommands, command, preferExplicitReferences()}
;



