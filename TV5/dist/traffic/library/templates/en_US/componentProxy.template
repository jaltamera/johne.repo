/**
GENERAL
-------
This template is used for agents which link to a component network. For example a 
Contact name is linked to the Name component. This template can be used to customize 
a component network. For example a Name component network used as an Email Sender 
may be customized to accept "from" as a keyword (which is not part of the keywords 
used in the component network). 

SUPPORTED FEATURES
------------------
The template supports IMPLICIT_MATCHING, PREFERENCE, REFERENCES, JOIN, GUESS (variables), CONTEXT LOOKUP, KEYWORD_ONLY_MATCH and VALUE_RANGE.

If IMPLICIT_MATCHING is supported then the agent will make a claim on the input even if the component's keyword 
(and its synonyms) wont appear in the input.

PREFERENCE is an xml attribute that will be associated to the actuation of the agent. The preference value 
can be examined outside the agent network to resolve ambiguities. For example the input "san francisco" can  cause an 
ambiguity between Find and a Map commands. The agent network will report the ambiguity. But the IO mode can
examine the preference attribute associted with the XML generated by Find and Map to decide which of Find or Map 
has the preference. For example Find may have a higher preference than Map and so the system can carry out the Find
command but also give a hint on the ambiguity occured so the user could disambiguate (e.g. by saying "map it").

The REFERENCES feature allows this field to be referenced using non-keyword reference words such as 'this', 'the', 'him' and it. 
In this case the reference attribute will be added to the generated XML with the type of reference. This attribute will 
be used for dereferencing (see the comments in system.template).

If JOIN is not supported then each claim made by this agent will include at most one instance of the 
component. If JOIN is supported then claims can include multiple instances of the component.
For example a referece to 3 name components when JOIN is supported will produce an XML look like:
<Name>...</Name>
<Name>...</Name>
<Name>...</Name>

If GUESS is supported then variables will be used to guess the field value. This is mostly useful
for searching a value when live interpretation is not possible or when user needs to know if
a field value exists. Agents guess what belongs to them by matching the input 
using one of the following patterns:
 - Right Guess: assumes the words on right side of an equalsTo pattern are a field value.
 - Left Guess: assumes that words on the left side of a valueOf pattern are a field value. 
 - Middle Guess: assumes the words between a BeforeValue and an AfterValue pattern are a field value.
All parameters for making a guess (min variable size, max variable size, and noise parameters) are customizable in this template. 

If CONTEXT LOOKUP is supported then the context will be used by the agent as a data source.
In this case the agent will use all elements with the agent's xml tag as data source.
For example assume that the following is part of the previous action of a Context:
<Name>
   <FirstName><![CDATA[Siamak]]></FirstName>
</Name>
<Name>
   <![CDATA[Babak]]>
</Name>
<Name>
   <![CDATA[Pegah]]>
</Name>
Then a Name agent will use 'Babak' and 'Pegah' (but not Siamak) as data and will try to match those to
the input. This is useful for claiming what has been guessed using the variable condition by 
this agent on a previous input. 

Currently the CONTEXT LOOKUP support is only for the previous action of the context.

If KEYWORD_ONLY_MATCH is supported then the agent will make a claim if a keyword is matched even if no data 
is matched.

If VALUE_RANGE is supported then upper bounds (greater than and greater than or equal) and lower bounds (less than 
and less than or equal) are understood. You may want to add synonyms for the keywords used to interpret upper bounds 
(ie. gt and ge) and lower bounds (ie. lt and le) in the synonym table of the agent (for example  assign >, >=, < 
and <= to the value range keywords).

The template also supports ambiguity recognition and disambiguation. 

*/

/** What is the keyword that identifies this component? */
String keyword = this.tag;

/** Reference words that must be adjacent to the keyword */
Condition adjacentReference = 'this'|'that'|'those'|'the'|'these';
/** Explicit reference keywords */
Condition explicitReference = '';

/** What is the preposition for this component? (e.g. 'in' or 'at' are used for a place)*/
String preposition;

/** What is the priority associated with this field... priorities can be examined outside the agent network
    to resolve ambiguities */
String preference;

/** What is the role of this template/agent? This is going to be used as an XML attribute associated to the XML element created by this template*/
constant String type = 'componentProxy';

/** The database column name used for generating SQL 
  * @deprecated 
  */
String columnName = '';

/** Should the SQL value use single quotes 
  * @deprecated 
  */
Boolean useQuotesInSql = false;

/** These flags are used to set or reset certain features in the polcies created by this template*/

/** Should the policies support implicit matches? (that is when a component is referenced in the input but the keyword used for
    that component is not referenced) */
Boolean implicitMatch = true;
/** Should the agent make a claim if a keyword is matched but no data is matched? */
Boolean supportKeywordOnlyMatch = true;
/** Should the policies support value ranges (eg. gt, lt, ge, le)? */
Boolean supportValueRange = false;
/** Should the agent use the context as a data source?  */
Boolean supportContextLookup = true;
/** Should variables be used to guess the value of this field in the pattern: <i>variable</i> isValueOf */
Boolean supportLeftGuess = false;
/** Should variables be used to guess the value of this field in the pattern: equalsTo <i>variable</i> */
Boolean supportRightGuess = true;
/** Should variables be used to guess the value of this field in the pattern: beforeValue <i>variable</i> afterValue*/
Boolean supportMiddleGuess = true;

/** Should the policies support ORing field values to eachother? (ORs and ANDs)*/
Boolean supportJoin = true;
/** The condition used to identify an OR join*/
Condition orKeyword = 'or';
/** The condition used to identify an AND join*/
Condition andKeyword = 'and';
/* What is the minimum number of tokens that should be used as a variable. <br>Used only if supportGuess is true */
Integer minVariableSize = 1; 
/* What is the maximum number of tokens that should be used as a variable. <br>Used only if supportGuess is true */
Integer maxVariableSize = 3; 
/* What is the minimum size of a non-noise token (in characters). Noise tokens will not be claimed as part of a variable. <br>Used only if supportGuess is true */
Integer minVariableNonNoiseTokenSize = 1; 
/* What is the file used to list noise words. Noise words will not be claimed as part of a variable. <br>Used only if supportGuess is true */
File variableNoiseFile = 'variable_noise.txt'; 


/** This condition is used to match explicit claims on exact matches to a <i>field</i> value.<br>
    Should be a combination of any string literal, preposition, kwd and adjacentReference.<br>
  */
Condition equalsTo = [preposition] ~ (kwd|adjacentReference) ~ (['is'] ~ ['equal' ~ ['to']]|'isEqualTo'|'=');
/** This condition is used to match explicit claims on contains matches to a <i>field</i> value.<br>
    Should be a combination of any string literal, preposition, kwd and adjacentReference.<br>
  */
Condition contains = [preposition] ~ (kwd|adjacentReference) ~ ('contains'|'containing'|'include'|'including');
/** This condition is used to match explicit claims on starts with matches to a <i>field</i> value.<br>
    Should be a combination of any string literal, preposition, kwd and adjacentReference.<br>
  */
Condition startsWith = [preposition] ~ (kwd|adjacentReference) ~ ('startsWith'|'starts with'|'starting with'|'which start with'|'that start with'|'which starts with'|'that starts with');
/** This condition is used to match explicit claims on ends with  matches to a <i>field</i> value.<br>
    Should be a combination of any string literal, preposition, kwd and adjacentReference.<br>
  */
Condition endsWith = [preposition] ~ (kwd|adjacentReference) ~ ('endsWith'|'ends with'|'ending with'|'which end with'|'that end with'|'which ends with'|'that ends with');

/** The condition used to match explicit claims on the exact value this agent is representing.<br>
    Should be a combination of any string literal, kwd and adjacentReference
  */
Condition isValueOf = ('isValueOf' | ('is' ~ ['the'] ~ 'value of')) (kwd|adjacentReference);

/** The condition used to match explicit claims on the part of the value this agent is representing.<br>
    Should be a combination of any string literal, kwd and adjacentReference
  */
Condition isPartOf = ('isPartOf' | ('is part of')) (kwd|adjacentReference);

/** The condition used to match explicit claims on the start of the value this agent is representing.<br>
    Should be a combination of any string literal, kwd and adjacentReference
  */
Condition isStartOf = ('isStartOf' | ('is start of')) (kwd|adjacentReference);
/** The condition used to match explicit claims on the end of the value this agent is representing.<br>
    Should be a combination of any string literal, kwd and adjacentReference
  */
Condition isEndOf = ('isEndOf' | ('is end of')) (kwd|adjacentReference);

/** conditions that come before and after a value */
Condition beforeValue = '';
Condition afterValue = '';
/** How should the value of this field be used to narrow down the previous input? 
    Valid values are: add, addNew and replace 
    If replace (which is the default if no values is associated with this property) then the 
    the old field value will be removed when new field value is added.
    If add then the new field value will be added along with the old field value.
    If addNew then a new command will be added and this field will be part of the component referenced in the new command (old command will be kept in the output as well)

    Example:
    for a pizza component the size and crust fields can be seen as fields that should always be replaced on followup.
    for example: 
    "small pizza"
    "..large pizza"
    you don't want to end up with a pizza which is both small and large

    However you may decide that new toppings should always be added to old toppigs when you followup.
    for example:
    "pepperoni pizza"
    "..ham"
    you want to end up with a "pepperoni and ham pizza"

    Then you may decide that the count for a pizza always means that a new order is comming:
    "1 pepperoni pizza"
    "..2 small ones"
    "..and one large pizza"
    you want to end up with three orders for 5 pizzas (1 pepperoni, 2 small and one large)
*/    
String defaultSlotFilling;

/**
    By default this is not a single slot. But you can set this to true.
*/
Boolean singleSlot;

/* live interpretation table name - often used for auto complete */
String liveInterpretationTable;

preposition:
    this.preposition
    {attributes: 'private, atomic'}
    {action: ''}
;

/** Claims keywords used for this field */
keyword:
    this.keyword | /CONTEXT:KWD(this.tag)
    {attributes: 'private, atomic'}
    {action: addAttribute('explicit', 'true')}
;

/** Claims keywords optionally following a preposition */
kwd:
    [preposition] ~ keyword
    {attributes: 'private, atomic'}
    {action: 
         addAttribute('explicit', 'true')}
;

/** Actuated when the user references this component without referencing any values */
onlyKwd:
    this.supportKeywordOnlyMatch & kwd
    {attributes: 'private, atomic'}
    {priority: topicScope(this)}
    {action: com.dejima.core.nlp.text.action.ComponentProxyActuation: 
         setTag(this.tag), setColumnName(this.columnName), setUseSqlQuotes(this.useQuotesInSql), addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), kwd}
;

/** This policy is actuated when the user references this component using adjacent references (eg. "the", "this",...)  */
adjacentReferenceIndicator:
    this.supportKeywordOnlyMatch & (<exact> (this.adjacentReference))
    {attributes: 'private, atomic'}
    {action: addAttribute('reference', *)}
;

/** Adjacent references always come before the keyword (eg. "the contact", "this contact",...) */
adjacentReference:
     this.supportKeywordOnlyMatch & (adjacentReferenceIndicator ~ keyword)
    {attributes: 'private, atomic'}
    {action: adjacentReferenceIndicator, keyword}
;

/** Explicit references are used instead of the component keyword (eg. "it", "her", "him",...) */
explicitReference:
    this.supportKeywordOnlyMatch & <check('previous_action',this)> & (<exact> (this.explicitReference))
    {attributes: 'private, atomic'}
    {action: addAttribute('reference', *)}
;

/** This policy is actuated when the user references this component using explicit references (eg. "it", "her", "him",...)  */
onlyReference:
    this.supportKeywordOnlyMatch & ([preposition] ~ (explicitReference|adjacentReference))
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.ComponentProxyActuation: 
         setTag(this.tag), setColumnName(this.columnName), setUseSqlQuotes(this.useQuotesInSql), addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), explicitReference, adjacentReference}
;

/** This policy claims any form of references (adjacent or explicit) */
reference: 
    [preposition] ~ (adjacentReference | explicitReference)
    {attributes: 'private, atomic'}
    {action: adjacentReference, explicitReference}
;

/** Claims on the context */
contextMatch:
    (this.supportContextLookup & /CONTEXT (this.tag)) 
    {attributes: 'private, atomic'}
    {action: addCData(*.matched)}
;

/** There should only be one down-chain agent referenced by this component*/
referencedComponent:
    [preposition] ~ (this.children | contextMatch)
    {attributes: 'private'}
    {action: this.children, contextMatch}
;

supportGuess:
    this.supportLeftGuess | this.supportRightGuess | this.supportMiddleGuess
    {attributes: 'private'}
;
   
variable:
    supportGuess & (?:(this.minVariableSize,this.maxVariableSize):this.minVariableNonNoiseTokenSize:this.variableNoiseFile | ('\'' ? '\'') | ('"' ? '"'))
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.FieldActuation: 
         setTag(get(this.children, 'Tag')), setUri(get(this.children, 'Uri')), addCData(?)}
;

value:
    referencedComponent | variable
    {attributes: 'private'}
;

gtValue:
    this.supportValueRange & (['is'] ~ 'gt' ~ value)
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.EntityActuation: 
         addAttribute('op','gt'), value}
;

ltValue:
    this.supportValueRange & (['is'] ~ 'lt' ~ value)
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.EntityActuation: 
         addAttribute('op','lt'), value}
;

geValue:
    this.supportValueRange & (['is'] ~ 'ge' ~ value)
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.EntityActuation: 
         addAttribute('op','ge'), value}
;

leValue:
    this.supportValueRange & (['is'] ~ 'le' ~ value)
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.EntityActuation:
         addAttribute('op','le'), value}
;

beforeValue:
    this.beforeValue
    {attributes: 'private, atomic'}
;

afterValue:
    this.afterValue
    {attributes: 'private, atomic'}
;

equalsTo:
    this.equalsTo
    {attributes: 'private, atomic'}
;

startsWith:
    this.startsWith
    {attributes: 'private, atomic'}
    {action: addAttribute('match','startsWith')}
;

endsWith:
    this.endsWith
    {attributes: 'private, atomic'}
    {action: addAttribute('match','endsWith')}
;

contains:
    this.contains
    {attributes: 'private, atomic'}
    {action: addAttribute('match','contains')}
;

isValueOf:
    this.isValueOf
    {attributes: 'private, atomic'}
;

isStartOf:
    this.isStartOf - (this.isStartOf ~ <exists> referencedComponent)
    {attributes: 'private, atomic'}
    {action: addAttribute('match','startsWith')}
;

isEndOf:
    this.isEndOf - (this.isEndOf ~ <exists> referencedComponent)
    {attributes: 'private, atomic'}
    {action: addAttribute('match','endsWith')}
;

isPartOf:
    this.isPartOf - (this.isPartOf ~ <exists> referencedComponent)
    {attributes: 'private, atomic'}
    {action: addAttribute('match','contains')}
;

leadingMatchCondition:
   equalsTo | startsWith | endsWith | contains
   {attributes: 'private, atomic'}
;

trailingMatchCondition:
   isValueOf | isStartOf | isEndOf | isPartOf
   {attributes: 'private, atomic'}
;

middleVariable:
    supportGuess & (beforeValue ? afterValue)
    {attributes: 'private, atomic'}
    {action: beforeValue, afterValue, addCData(?)}
;
   
/** This policy makes claims if the input explicitly refers to this field (field keywords are used in the input) */
certainlyExplicit:
    (beforeValue ~ referencedComponent ~ afterValue) | 
    (leadingMatchCondition ~ referencedComponent) | 
    (referencedComponent ~ trailingMatchCondition) |
    (this.supportMiddleGuess & (middleVariable)) | 
    (this.supportRightGuess & (leadingMatchCondition ~ variable)) |
    (this.supportLeftGuess & ([preposition] ~ variable ~ trailingMatchCondition)) |
    ([preposition] ~ (keyword|adjacentReference) (
       gtValue | ltValue | geValue | leValue
    ))
    {attributes: 'private, atomic'}
    {action: leadingMatchCondition, trailingMatchCondition, keyword, referencedComponent, middleVariable,  variable, adjacentReference, beforeValue, afterValue, gtValue, ltValue, geValue, leValue}
;

maybeExplicit:
    (equalsTo & referencedComponent) | (referencedComponent & isValueOf)
    {attributes: 'private'}
    {action: equalsTo, isValueOf, referencedComponent}
;

/** give higher priority to explicit component references */
explicitComponentReference: 
   <includes(referencedComponent)> certainlyExplicit
   {priority: 10001}
   {attributes: 'private'}
   {action: certainlyExplicit}
;

explicitGuess:
   certainlyExplicit - explicitComponentReference
   {action: certainlyExplicit}
;

explicit: 
   explicitComponentReference | explicitGuess | maybeExplicit
   {attributes: 'private'}
;


/** This policy makes claims if implicit matching is supported */
implicit:
   this.implicitMatch & (
      referencedComponent |
      gtValue | ltValue | geValue | leValue 
   )
   {attributes: 'private'}
   {action: referencedComponent, gtValue, ltValue, geValue, leValue}
;

aComponent:
    explicit | implicit | reference
    {attributes: 'private'}
;

component:
    aComponent
    {attributes: 'private'}
    {action: com.dejima.core.nlp.text.action.ComponentProxyActuation: 
         setTag(this.tag), setColumnName(this.columnName), setUseSqlQuotes(this.useQuotesInSql), addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), aComponent}
;
	 
andJoin:
    this.andKeyword
    {attributes: 'private, atomic'}
    {action:  
       addAttribute('join', 'and')}
;

orJoin:
    this.orKeyword
    {attributes: 'private, atomic'}
    {action:  
       addAttribute('join', 'or')}
;

joinOperation:
    orJoin | andJoin
    {attributes: 'private, atomic'}
;

joinedComponent:
    this.supportJoin & (joinOperation ~ aComponent)
    {attributes: 'private'}
    {action: com.dejima.core.nlp.text.action.ComponentProxyActuation: 
         setTag(this.tag), setColumnName(this.columnName), setUseSqlQuotes(this.useQuotesInSql), addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), joinOperation, aComponent}
;

joinedComponents:
    this.supportJoin & (component ~^ joinedComponent)
    {attributes: 'private'}
;

main:
    (onlyReference | onlyKwd | joinedComponents | component)+
;
