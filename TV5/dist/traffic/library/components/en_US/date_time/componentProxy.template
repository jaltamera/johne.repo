/**
GENERAL
-------
This template is used for agents which link to a component network. For example a 
Contact name is linked to the Name component. This template can be used to customize 
a component network. For example a Name component network used as an Email Sender 
may be customized to accept "from" as a keyword (which is not part of the keywords 
used in the component network). 

SUPPORTED FEATURES
------------------
The template supports IMPLICIT_MATCHING, PREFERENCE, REFERENCES, OR, GUESS (variables), CONTEXT LOOKUP, KEYWORD_ONLY_MATCH and VALUE_RANGE.

If IMPLICIT_MATCHING is supported then the agent will make a claim on the input even if the object's keyword 
(and its synonyms) wont appear in the input.

PREFERENCE is an xml attribute that will be associated to the actuation of the agent. The preference value 
can be examined outside the agent network to resolve ambiguities. For example the input "san francisco" can  cause an 
ambiguity between Find and a Map commands. The agent network will report the ambiguity. But the IO mode can
examine the preference attribute associted with the XML generated by Find and Map to decide which of Find or Map 
has the preference. For example Find may have a higher preference than Map and so the system can carry out the Find
command but also give a hint on the ambiguity occured so the user could disambiguate (e.g. by saying "map it").

The REFERENCES feature allows this field to be referenced using this, the and it. In this case the reference 
attribute will be added to the generated XML with the type of reference (it, the or this). 
The and This are hard coded. They should be used with the object keyword so it should be ‘the actor’ or ‘this actor’. 
The itKeyword should be declared in the template properties. If the it keyword is defined (to be ‘it’ or ‘him’ or ‘her’) 
then it can be used to reference the object without any keyword. So the input ‘him’ can be claimed by the Contact agent.

If OR is not supported then each claim made by this agent will include at most one instance of the 
component field. If OR is supported then claims can include multiple instances of the component field.
For example a referece to 3 name fields when OR is supported will produce an XML look like:
<Name>...</Name>
<Name>...</Name>
<Name>...</Name>

If GUESS is supported then variables will be used to guess the field. This is mostly useful
for out of scope commands where the field is not recognized. Support for guess can help in giving a 
proper response for out of scope requests (such as giving a hint or an error message).

If CONTEXT LOOKUP is supported then the context will be used by the agent as a data source.
In this case the agent will use all elements with the agent's xml tag as data source.
For example assume that the following is part of the previous action of a Context:
<Name>
   <FirstName><![CDATA[Siamak]]></FirstName>
</Name>
<Name>
   <![CDATA[Babak]]>
</Name>
<Name>
   <![CDATA[Pegah]]>
</Name>
Then a Name agent will use 'Babak' and 'Pegah' (but not Siamak) as data and will try to match those to
the input. This is useful for claiming what has been guessed using the variable condition by 
this agent on a previous input. 

Currently the CONTEXT LOOKUP support is only for the previous action of the context.

If KEYWORD_ONLY_MATCH is supported then the agent will make a claim if a keyword is matched even if no data 
is matched.

If VALUE_RANGE is supported then upper bounds (greater than and greater than or equal) and lower bounds (less than 
and less than or equal) are understood. You may want to add synonyms for the keywords used to interpret upper bounds 
(ie. gt and ge) and lower bounds (ie. lt and le) in the synonym table of the agent (for example  assign >, >=, < 
and <= to the value range keywords).

The template also supports ambiguity recognition and disambiguation. 

*/

/** What is the keyword that identifies this object? */
String keyword;
/** What is the preposition for this object? (e.g. 'in' or 'at' are used for a place)*/
String preposition;
String domainKeyword;

/** The word that can be used to reference to this object without naming it*/
String itKeyword;
/** What is the priority associated with this field... priorities can be examined outside the agent network
    to resolve ambiguities */
String preference;

/** These flags are used to set or reset certain features in the polcies created by this template*/

/** Should the policies support implicit matches? (that is when an object field is referenced in the input but the keyword used for
    that object is not referenced) */
Boolean implicitMatch = true;
/** Should the agent make a claim if a keyword is matched but no data is matched? */
Boolean supportKeywordOnlyMatch = true;
/** Should the policies support value ranges (eg. gt, lt, ge, le)? */
Boolean supportValueRange = false;
/** Should the policies support ORing fields? */
Boolean supportOR = true;
/** Should the agent use the context as a data source?  */
Boolean supportContextLookup = true;
/** Should variables be used to guess the value of this field? */
Boolean supportGuess = true;
/* What is the minimum number of tokens that should be used as a variable. Used only if supportGuess is true */
Integer minVariableSize = 1; 
/* What is the maximum number of tokens that should be used as a variable. Used only if supportGuess is true */
Integer maxVariableSize = 3; 
/* What is the minimum size of a non-noise token (in characters). Noise tokens will not be claimed as part of a variable. tokens that should be used as a variable. Used only if supportGuess is true */
Integer minVariableNonNoiseTokenSize = 1; 
/* What is the file used to list noise words. Noise words will not be claimed as part of a variable. tokens that should be used as a variable. Used only if supportGuess is true */
File variableNoiseFile = 'variable_noise.txt'; 

/** The condition used to match or statements of the object this agent is representing.
   Should be a combination of any string literal and object.
  */
Condition orMatch = object ~^ ('+' object);


/** Claims keywords used for this field */
kwd:
    [this.domainKeyword] this.keyword
    {attributes: 'private'}
    {priority: 1001}
    {action: addAttribute('explicit', 'true')}
;

onlyKwd:
    this.supportKeywordOnlyMatch & kwd
    {attributes: 'private'}
    {priority: 1001}
    {action: setTag(this.tag), addAttribute('preference', this.preference), kwd}
;

theReference:
    this.supportKeywordOnlyMatch & <exact> 'the' [this.domainKeyword] kwd
    {attributes: 'private'}
    {action: addAttribute('reference', 'the'), kwd}
;

thisReference:
    this.supportKeywordOnlyMatch & <exact> 'this' [this.domainKeyword] kwd
    {attributes: 'private'}
    {action: addAttribute('reference', 'this'), kwd}
;

itReference:
    this.supportKeywordOnlyMatch & <exact> this.itKeyword
    {attributes: 'private'}
    {action: addAttribute('reference', *)}
;

reference:
    theReference | thisReference | itReference
    {attributes: 'private'}
    {action: theReference, thisReference, itReference}
;

/** Claims on the context */
contextMatch:
    (this.supportContextLookup & /CONTEXT (this.tag)) 
    {attributes: 'private'}
    {action: addCData(*.matched)}
;

/** There should only be one down-chain agent used as the field of this object*/
fields:
    this.children | contextMatch
    {attributes: 'private'}
    {action: this.children, contextMatch}
;

variable:
    this.supportGuess & (?:(this.minVariableSize,this.maxVariableSize):this.minVariableNonNoiseTokenSize:this.variableNoiseFile | '\'' ? '\'' | '"' ? '"')
    {attributes: 'private'}
    {action: addCData(?)}
;

value:
    fields | variable
    {attributes: 'private'}
;

gtValue:
    this.supportValueRange & (['is'] 'gt'  value)
    {attributes: 'private'}
    {action: setTag('gt'), value}
;

ltValue:
    this.supportValueRange & (['is'] 'lt' value)
    {attributes: 'private'}
    {action: setTag('lt'), value}
;

geValue:
    this.supportValueRange & (['is'] 'ge' value)
    {attributes: 'private'}
    {action: setTag('gt'), addAttribute('inclusive','true'), value}
;

leValue:
    this.supportValueRange & (['is'] 'le' value)
    {attributes: 'private'}
    {action: setTag('lt'), addAttribute('inclusive','true'), value}
;

equalsTo:
    (kwd|theReference) ['is'] ['equal' ['to']]
    {attributes: 'private'}
    {action: kwd, theReference}
;

isEqual:
   ['is'] ['equal' ['to']] (kwd|theReference)
   {attributes: 'private'}
   {action: kwd, theReference}
;

/** This policy makes claims if the input explicitly refers to this field (field keywords are used in the input) */
explicit:
    (equalsTo fields) | 
    (fields isEqual) | 
    ([this.domainKeyword] [this.preposition] fields kwd) |
    equalsTo variable |
    [this.domainKeyword] this.preposition ['the'] variable kwd |
    ((kwd|theReference) (
        gtValue | ltValue | geValue | leValue | 
        ( ((gtValue|geValue) ['&'] [kwd|theReference] (ltValue|leValue)) | 
          ((ltValue|leValue) ['&'] [kwd|theReference] (gtValue|geValue)) ) 
     ))
    {attributes: 'private'}
    {action: equalsTo, isEqual, kwd, fields, variable, theReference, gtValue, ltValue, geValue, leValue}
;

/** This policy makes claims if implicit matching is supported */
implicit:
   this.implicitMatch & (
      [this.domainKeyword] [this.preposition] fields |
      gtValue | ltValue | geValue | leValue |
      ( ((gtValue|geValue) ['&'] [kwd|theReference] (ltValue|leValue)) | 
        ((ltValue|leValue) ['&'] [kwd|theReference] (gtValue|geValue)) )
    )
   {attributes: 'private'}
   {action: fields, gtValue, ltValue, geValue, leValue}
;

object:
    explicit | implicit | reference
    {attributes: 'private'}
    {action: setTag(this.tag), addAttribute('preference', this.preference), explicit, implicit, reference}
;
	 
/** Policy to support ORing of fields */
orObjects:
    this.supportOR & (this.orMatch)
    {attributes: 'private'}
;

main:
    (onlyKwd | orObjects | object)+
;
