/**
GENERAL
-------
This template is used for data fields. The values of a data field may be stored in a file, matched using live 
interpretation, matched using a down-chain data source agent, or matched using keywords and variables. The 
template also supports sync files, which can be synchronized with the master data source for the field every 
time a session with is started. The main difference between linking a data field with a file versus a sync file 
is that the data in the file is typically more static (such as English first names, State names, and so on) while 
sync file entries may change more regularly (such as sales opportunity names, daily weather report, and so on). 
If field values are dynamic and can change frequently then a live interpretation table or a datasource agent should
be used.

This template has a fieldValueSelector property which can be used to specify what should 
appear in the CData text. Options are: 0)inputMatched (default): The part of the input that has been matched, 1)patternMatched:
The pattern which the input has been matched to. 2)targetPattern: The pattern target. For example lets say the word 'san francisco' 
in the input is matched with the pattern: 'SF: San Francsico'. Then the inputMatched will be: 'san francisco', the patternTarget 
will be: 'SF', and the patternMatched is: 'San Francisco'.


SUPPORTED FEATURES
------------------
The template supports IMPLICIT_MATCHING, PREFERENCE, TYPE, REFERNCES, JOIN, GUESS (variables), CONTEXT_LOOKUP, KEYWORD_ONLY_MATCH and VALUE_RANGE.

If IMPLICIT_MATCHING is supported then the agent will make a claim on the input even if the object's keyword 
(and its synonyms) wont appear in the input.

PREFERENCE is an xml attribute that will be associated to the actuation of the agent. The preference value 
can be examined outside the agent network to resolve ambiguities. For example the input "san francisco" can  cause an 
ambiguity between Find and a Map commands. The agent network will report the ambiguity. But the IO mode can
examine the preference attribute associted with the XML generated by Find and Map to decide which of Find or Map 
has the preference. For example Find may have a higher preference than Map and so the system can carry out the Find
command but also give a hint on the ambiguity occured so the user could disambiguate (e.g. by saying "map it").

TYPE is an xml attribute which defines the role of this template. The type attribute of this template is 'field' (do not change the value of this attribute).

The REFERENCES feature allows this field to be referenced using non-keyword reference words such as 'this', 'the', 'him' and it. 
In this case the reference attribute will be added to the generated XML with the type of reference. This attribute will 
be used for dereferencing (see the comments in system.template). 

If JOIN is not supported then each claim made by this agent will include at most one instance of the 
field. If JOIN is supported then claims can include multiple instances of the field.
For example a referece to 3 first name fields when JOIN is supported will produce an XML look like:
<FirstName>...</FirstName>
<FirstName>...</FirstName>
<FirstName>...</FirstName>

If GUESS is supported then variables will be used to guess the field value. This is mostly useful
for searching a value when live interpretation is not possible or when user needs to know if
a field value exists. Agents guess what belongs to them by matching the input 
using one of the following patterns:
 - Right Guess: assumes the words on right side of an equalsTo pattern are a field value.
 - Left Guess: assumes that words on the left side of a valueOf pattern are a field value. 
 - Middle Guess: assumes the words between a BeforeValue and an AfterValue pattern are a field value.
All parameters for making a guess (min variable size, max variable size, and noise parameters) are customizable in this template. 

The template also supports ambiguity recognition and disambiguation. 

If CONTEXT_LOOKUP is supported then the context will be used by the agent as a data source.
In this case the agent will use all elements with the agent's xml tag as data source.
For example assume that the following is part of the previous action of a Context:
<Name>
   <FirstName><![CDATA[Siamak]]></FirstName>
</Name>
<Name>
   <FirstName><![CDATA[Babak]]></FirstName>
</Name>
<Name>
   <![CDATA[Pegah]]>
</Name>

Then a FirstName agent will use 'Siamak' and 'Babak' (but not 'Pegah') as data and will try to match those to
the input. This is useful for claiming what has been guessed using the variable condition by 
this agent on a previous input. The guesses wont be claimed by the other data sources 
(file, database, etc.).

Currently the CONTEXT LOOKUP support is only for the previous action of the context.

If KEYWORD_ONLY_MATCH is supported then the agent will make a claim if a keyword is matched even if no data 
is matched.

If VALUE_RANGE is supported then upper bounds (greater than and greater than or equal) and lower bounds (less than 
and less than or equal) are understood. You may want to add synonyms for the keywords used to interpret upper bounds 
(ie. gt and ge) and lower bounds (ie. lt and le) in the synonym table of the agent (for example  assign >, >=, < 
and <= to the value range keywords).

*/

/** What is the keyword that identifies this field? */
String keyword = this.tag;
/** The name of the file where the field values stored */
File file;
/** The name of the file used for Syncing with the main data source 
 * @deprecated 
 */
File syncFile;
/** The name of the noise file used for data values */
File noiseFile = 'common.txt';
/** The min noise file token length */
Integer noiseMinTokenLength = 2;
/** The name of the table used for live interpretation */
String liveInterpretationTable = this.tag;
/** Name of the DataSourceAgent (should be a down chain agent) */
Condition datasourceAgent = '';
/** Reference words that must be adjacent to the keyword */
Condition adjacentReference = 'this'|'that'|'those'|'the'|'these';
/** Explicit reference keywords */
Condition explicitReference = '';

/** What is the preposition for this field? (e.g. 'in' or 'at' are used for a place)
    preposition can come right before the data (e.g. 'in san francsisco'),
    or it can come right before the keyword (e.g. 'in city;)
    or it can come right before the reference (e.g. 'in there')*/
String preposition;
/** What is the priority associated with this field... priorities can be examined outside the agent network
    to resolve ambiguities */
String preference;

/** What is the role of this template/agent? This is going to be used as an XML attribute associated to the XML element created by this template*/
constant String type = 'field';

/** The database column name used for generating SQL 
 * @deprecated 
 */
String columnName = '';

/** Should the SQL value use single quotes 
 * @deprecated 
 */
Boolean useQuotesInSql = true;

/** fieldValueSelector property to specify which of the below should be used in the field's CData text:
<ul>
<li>0:inputMatched (*)
<li>1:patternMatched (*.matched)
<li>2:targetMatched (*.target)
<li>3:auto-select (one of *, *.matched or *.target)
</ul>
For example if the input "Willi" mathces "William" which is a synonym of "Bill" then:<br>
inputMatched is: Willi<br>
patternMatched is: William<br>
targetMatched is: Bill<br>

The auto-select will choose inputMatched if the inputMatched is a substring of targetMatched, 
otherwise, it will select the patternMatched if that is a substring of the targetMatched,
otherwise, it will select the target matched. So in the example above "Bill" will be selected
by the auto-select.

As another example lets say the input "Wili" mathces "Willi" which is a synonym of "William" then
the auto-select will choose the patternMatched ("Willi"). 

Note: In auto-select mode, if the targetMatched is a number then the targetMatched is selected no matter what. 
 */
Integer fieldValueSelector = 3;

/** These flags are used to set or reset certain features in the polcies created by this template*/

/** Should the policies support implicit matches? (that is when a field value is referenced in the input but the keyword used for
    that field is not referenced) */
Boolean implicitMatch = true;
/** Should the policies support matches if they are not certainly explicit? (that is when a field and keyword are referenced in the input but they are not adjacent to eachother */
Boolean maybeExplicitMatch = false;
/** Should the agent make a claim if a keyword is matched but no data is matched? */
Boolean supportKeywordOnlyMatch = true;
/** Should the policies support value ranges (eg. gt, lt, ge, le)? */
Boolean supportValueRange = false;
/** Should the policies support joining field values to eachother? (ORs and ANDs)*/
Boolean supportJoin = true;
/** The condition used to identify an OR join*/
Condition orKeyword = 'or';
/** The condition used to identify an AND join*/
Condition andKeyword = 'and';
/** Should the agent use the context as a data source?  */
Boolean supportContextLookup = true;
/** Should variables be used to guess the value of this field in the pattern: <i>variable</i> isValueOf */
Boolean supportLeftGuess = true;
/** Should variables be used to guess the value of this field in the pattern: equalsTo <i>variable</i> */
Boolean supportRightGuess = true;
/** Should variables be used to guess the value of this field in the pattern: beforeValue <i>variable</i> afterValue*/
Boolean supportMiddleGuess = true;

/* What is the minimum number of tokens that should be used as a variable.<br> Used only if supportGuess is true */
Integer minVariableSize = 1; 
/* What is the maximum number of tokens that should be used as a variable.<br> Used only if supportGuess is true */
Integer maxVariableSize = 3; 
/* What is the minimum size of a non-noise token (in characters). <br>Noise tokens will not be claimed as part of a variable. <br>Used only if supportGuess is true */
Integer minVariableNonNoiseTokenSize = 1; 
/* What is the file used to list noise words. Noise words will not be claimed as part of a variable. <br>Used only if supportGuess is true */
File variableNoiseFile = 'variable_noise.txt'; 

/** This condition is used to match explicit claims on exact matches to a <i>field</i> value.<br>
    Should be a combination of any string literal, preposition, kwd and adjacentReference.<br>
  */
Condition equalsTo = [preposition] ~ (kwd|adjacentReference) ~ (['is'] ~ ['equal' ~ ['to']]|'isEqualTo'|'=');
/** This condition is used to match explicit claims on contains matches to a <i>field</i> value.<br>
    Should be a combination of any string literal, preposition, kwd and adjacentReference.<br>
  */
Condition contains = [preposition] ~ (kwd|adjacentReference) ~ ('contains'|'containing'|'include'|'including');
/** This condition is used to match explicit claims on starts with matches to a <i>field</i> value.<br>
    Should be a combination of any string literal, preposition, kwd and adjacentReference.<br>
  */
Condition startsWith = [preposition] ~ (kwd|adjacentReference) ~ ('startsWith'|'starts with'|'starting with'|'which start with'|'that start with'|'which starts with'|'that starts with');
/** This condition is used to match explicit claims on ends with  matches to a <i>field</i> value.<br>
    Should be a combination of any string literal, preposition, kwd and adjacentReference.<br>
  */
Condition endsWith = [preposition] ~ (kwd|adjacentReference) ~ ('endsWith'|'ends with'|'ending with'|'which end with'|'that end with'|'which ends with'|'that ends with');

/** The condition used to match explicit claims on the exact value this agent is representing.<br>
    Should be a combination of any string literal, kwd and adjacentReference
  */
Condition isValueOf = ('isValueOf' | ('is' ~ ['the'] ~ 'value of')) (kwd|adjacentReference);

/** The condition used to match explicit claims on the part of the value this agent is representing.<br>
    Should be a combination of any string literal, kwd and adjacentReference
  */
Condition isPartOf = ('isPartOf' | ('is part of')) (kwd|adjacentReference);

/** The condition used to match explicit claims on the start of the value this agent is representing.<br>
    Should be a combination of any string literal, kwd and adjacentReference
  */
Condition isStartOf = ('isStartOf' | ('is start of')) (kwd|adjacentReference);
/** The condition used to match explicit claims on the end of the value this agent is representing.<br>
    Should be a combination of any string literal, kwd and adjacentReference
  */
Condition isEndOf = ('isEndOf' | ('is end of')) (kwd|adjacentReference);

/** condition that comes before a value in the condition: (beforeValue value afterValue)*/
Condition beforeValue = '';
/** condition that comes after a value in the condition: (beforeValue value afterValue)*/
Condition afterValue = '';

/** condition used for claiming greater than value ranges */
Condition gtCondition = (['is'] ~ ('gt'|'>') ~ value);
/** condition used for claiming greater than or equal value ranges */
Condition geCondition = (['is'] ~ ('ge'|'>=') ~ value);
/** condition used for claiming less than value ranges */
Condition ltCondition = (['is'] ~ ('lt'|'<') ~ value);
/** condition used for claiming less than or equal value ranges */
Condition leCondition = (['is'] ~ ('le'|'<=') ~ value);

/** How should the value of this field be used to narrow down the previous input? 
    Valid values are: add, addNew and replace 
    If replace (which is the default if no values is associated with this property) then the 
    the old field value will be removed when new field value is added.
    If add then the new field value will be added along with the old field value.
    If addNew then a new command will be added and this field will be part of the field referenced in the new command (old command will be kept in the output as well)

    Example:
    for a pizza object the size and crust fields can be seen as fields that should always be replaced on followup.
    for example: 
    "small pizza"
    "..large pizza"
    you don't want to end up with a pizza which is both small and large

    However you may decide that new toppings should always be added to old toppigs when you followup.
    for example:
    "pepperoni pizza"
    "..ham"
    you want to end up with a "pepperoni and ham pizza"

    Then you may decide that the count for a pizza always means that a new order is comming:
    "1 pepperoni pizza"
    "..2 small ones"
    "..and one large pizza"
    you want to end up with three orders for 5 pizzas (1 pepperoni, 2 small and one large)
*/    
String defaultSlotFilling;

preposition:
    this.preposition
    {attributes: 'private, atomic'}
    {action: ''}
;

/** Claims keywords used for this field */
keyword:
    this.keyword | /CONTEXT:KWD(this.tag)
    {attributes: 'private, atomic'}
    {action: addAttribute('explicit', 'true')}
;

/** Claims keywords optionally following a preposition */
kwd:
    [preposition] ~ keyword
    {attributes: 'private, atomic'}
;

/** Actuated when the user references this field without referencing a value (data)
    Makes a claim only if either supportKeywordOnlyMatch is true or if this agent is part of a previous ambiguity.
    */
onlyKwd:
    this.supportKeywordOnlyMatch & kwd | <check('previous_ambiguity', this)> & kwd
    {attributes: 'private, atomic'}
    {priority: topicScope(this)}
    {action: com.dejima.core.nlp.text.action.FieldActuation: 
       setTag(this.tag), setColumnName(this.columnName), setUseSqlQuotes(this.useQuotesInSql),addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(true), kwd}
;

/** This policy is actuated when the user references this field using adjacent references (eg. "the", "this",...)  */
adjacentReferenceIndicator:
    (<exact> (this.adjacentReference))
    {attributes: 'private, atomic'}
    {action: addAttribute('reference', *)}
;

/** Adjacent references always come before the keyword (eg. "the contact", "this contact",...) */
adjacentReference:
    (adjacentReferenceIndicator keyword)
    {attributes: 'private, atomic'}
    {action: adjacentReferenceIndicator, keyword}
;

/** Explicit references are used instead of the field keyword (eg. "it", "her", "him",...) */
explicitReference:
    <check('previous_action',this)> & (<exact> (this.explicitReference))
    {attributes: 'private, atomic'}
    {action: addAttribute('reference', *)}
;

/** This policy is actuated when the user references this field ony using an explicit references (eg. "it", "her", "him",...) or adjacent reference (eg. 'the name') */
onlyReference:
    this.supportKeywordOnlyMatch & ([preposition] ~ (explicitReference|adjacentReference))
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.FieldActuation: 
       setTag(this.tag), setColumnName(this.columnName), setUseSqlQuotes(this.useQuotesInSql), addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(true), explicitReference, adjacentReference}
;

/** This policy claims any form of references (adjacent or explicit). this policy is actuated if the user references this field and some values (eg. 'find him or john') */
reference: 
    this.supportKeywordOnlyMatch & ([preposition] ~ (adjacentReference | explicitReference))
    {attributes: 'private, atomic'}
    {action: adjacentReference, explicitReference}
;

/** Used when values can come from a down-chain DataSourceAgent */
datasource:
   this.datasourceAgent
   {attributes: 'private, atomic'}
;

/** This policy claims by matching inputs to data in file, sync file, live interpretation or context */
dbData:
    (this.supportContextLookup & /CONTEXT (this.tag)) | 
    <exact> /F:LINE this.file:this.noiseMinTokenLength:this.noiseFile |
    <exact> /F:LINE this.syncFile:this.noiseMinTokenLength:this.noiseFile |
    /IDB this.liveInterpretationTable
    {attributes: 'private, atomic'}
    {action: addField(*, *.matched, *.target, this.fieldValueSelector)}
;

data: 
   [preposition] ~ (dbData | datasource)
   {attributes: 'private, atomic'}
;
   
supportGuess:
    this.supportLeftGuess | this.supportRightGuess | this.supportMiddleGuess
    {attributes: 'private'}
;
   
variable:
    supportGuess & (?:(this.minVariableSize,this.maxVariableSize):this.minVariableNonNoiseTokenSize:this.variableNoiseFile | ('\'' ? '\'') | ('"' ? '"'))
    {attributes: 'private, atomic'}
    {action: addCData(?)}
;

beforeValue:
    this.beforeValue
    {attributes: 'private, atomic'}
;

afterValue:
    this.afterValue
    {attributes: 'private, atomic'}
;

value:
    data | ([preposition] variable)
    {attributes: 'private, atomic'}
;

gtValue:
    this.supportValueRange & (this.gtCondition)
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.FieldActuation:  
       addAttribute('op','gt'), value}
;

ltValue:
    this.supportValueRange & (this.ltCondition)
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.FieldActuation:  
       addAttribute('op','lt'), value}
;

geValue:
    this.supportValueRange & (this.geCondition)
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.FieldActuation:  
       addAttribute('op','ge'), value}
;

leValue:
    this.supportValueRange & (this.leCondition)
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.FieldActuation: 
       addAttribute('op','le'), value}
;

equalsTo:
    this.equalsTo
    {attributes: 'private, atomic'}
;

startsWith:
    this.startsWith
    {attributes: 'private, atomic'}
    {action: addAttribute('match','startsWith')}
;

endsWith:
    this.endsWith
    {attributes: 'private, atomic'}
    {action: addAttribute('match','endsWith')}
;

contains:
    this.contains
    {attributes: 'private, atomic'}
    {action: addAttribute('match','contains')}
;

isValueOf:
    this.isValueOf - (this.isValueOf ~ <exists> data)
    {attributes: 'private, atomic'}
;

isStartOf:
    this.isStartOf - (this.isStartOf ~ <exists> data)
    {attributes: 'private, atomic'}
    {action: addAttribute('match','startsWith')}
;

isEndOf:
    this.isEndOf - (this.isEndOf ~ <exists> data)
    {attributes: 'private, atomic'}
    {action: addAttribute('match','endsWith')}
;

isPartOf:
    this.isPartOf - (this.isPartOf ~ <exists> data)
    {attributes: 'private, atomic'}
    {action: addAttribute('match','contains')}
;

leadingMatchCondition:
   equalsTo | startsWith | endsWith | contains
   {attributes: 'private, atomic'}
;

trailingMatchCondition:
   isValueOf | isStartOf | isEndOf | isPartOf
   {attributes: 'private, atomic'}
;

middleVariable:
    supportGuess & (beforeValue ? afterValue)
    {attributes: 'private, atomic'}
    {action: beforeValue, afterValue, addCData(?)}
;
   
/** This policy makes claims if the input explicitly refers to this field (field keywords are used in the input) */
certainlyExplicit:
    ([preposition] ~ data ~ keyword) | /*eg. with high priority*/
    (beforeValue ~ data ~ afterValue) | 
    (leadingMatchCondition ~ data) | 
    (data ~ trailingMatchCondition) |
    (this.supportMiddleGuess & middleVariable) | 
    (this.supportRightGuess & (leadingMatchCondition ~ variable)) |
    (this.supportLeftGuess & ([preposition] ~ variable ~ trailingMatchCondition)) |
    ([preposition] ~ (keyword|adjacentReference) (
       gtValue | ltValue | geValue | leValue
    ))
   {attributes: 'private, atomic'}
   {priority: 10001}
   {action: leadingMatchCondition, trailingMatchCondition, keyword, data, middleVariable,  variable, adjacentReference, beforeValue, afterValue, gtValue, ltValue, geValue, leValue}
;

/** This policy makes claims if the input may be explicitly referencing to this field (field keywords are used in the input but they are not adjacent to field values) */
maybeExplicit:
    this.maybeExplicitMatch & (leadingMatchCondition & data | data & trailingMatchCondition)
    {attributes: 'private'}
    {action: leadingMatchCondition, trailingMatchCondition, data}
;

explicit: 
   certainlyExplicit | maybeExplicit
   {attributes: 'private'}
;

/** This policy makes claims on values */
implicitValue:
      data |
      gtValue | ltValue | geValue | leValue
   {attributes: 'private'}
   {action: data, gtValue, ltValue, geValue, leValue}
;

/** This policy makes claims if implicit matching is supported */
implicit:
    (this.implicitMatch | <check('previous_action',this)>) & implicitValue
   {attributes: 'private'}
   {action: implicitValue}
;

/**
 * A single field.
 */
aField:
    explicit | implicit | reference
    {attributes: 'private'}
;

field:
    aField
    {attributes: 'private'}
    {action: com.dejima.core.nlp.text.action.FieldActuation: 
       setTag(this.tag), setColumnName(this.columnName), setUseSqlQuotes(this.useQuotesInSql), addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(true), aField}
;

andJoin:
    this.andKeyword
    {attributes: 'private, atomic'}
    {action:  
       addAttribute('join', 'and')}
;

orJoin:
    this.orKeyword
    {attributes: 'private, atomic'}
    {action:  
       addAttribute('join', 'or')}
;

joinOperation:
    orJoin | andJoin
    {attributes: 'private, atomic'}
;

joinedField:
    this.supportJoin & (joinOperation ~ (aField | implicitValue))
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.FieldActuation: 
       setTag(this.tag), setColumnName(this.columnName), setUseSqlQuotes(this.useQuotesInSql), addAttribute('type', this.type), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(true), joinOperation, aField, implicitValue}
;

joinedFields:
    this.supportJoin & (field ~^ joinedField)
    {attributes: 'private'}
;

main:
    (onlyReference | onlyKwd | joinedFields | field)+
;
