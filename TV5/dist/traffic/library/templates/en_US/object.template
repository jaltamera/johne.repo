/**
GENERAL
-------
This template is used for objects which join two or more fields. 
For example a Contact object joins Contact's name, address and phone number.

SUPPORTED FEATURES
------------------
The template supports IMPLICIT_MATCHING, PREFERENCE, TYPE, GROUPS, AMBIGUITY, REFERENCES, JOIN, GUESS (variables), CONTEXT LOOKUP, KEYWORD_ONLY_MATCH,
RECENCY and MUTLIPLE_INSTANCES.

If IMPLICIT_MATCHING is supported then the agent will make a claim on the input even if the object's keyword 
(and its synonyms) wont appear in the input.

PREFERENCE is an xml attribute that will be associated to the actuation of the agent. The preference value 
can be examined outside the agent network to resolve ambiguities. For example the input "san francisco" can  cause an 
ambiguity between Find and a Map commands. The agent network will report the ambiguity. But the IO mode can
examine the preference attribute associted with the XML generated by Find and Map to decide which of Find or Map 
has the preference. For example Find may have a higher preference than Map and so the system can carry out the Find
command but also give a hint on the ambiguity occured so the user could disambiguate (e.g. by saying "map it").

TYPE is an xml attribute which defines the role of this template. The type attribute of this template is 'object' (do not change the value of this attribute).

GROUPS is an xml attribute which defines which groups does this object belongs to (eg. MOVIE belongs to entertainment and arts).
The groups attribute is used to create the list of relevant commands.

If AMBIGUITY is supported then ambiguities are detected and ambiguous actuations are generated.

The REFERENCES feature allows this field to be referenced using non-keyword reference words such as 'this', 'the', 'him' and it. 
In this case the reference attribute will be added to the generated XML with the type of reference. This attribute will 
be used for dereferencing (see the comments in system.template).

If JOIN is not supported then each claim made by this agent will include at most one instance of each  
field. If JOIN is supported then claims can include multiple instances of each field.
For example a referece to a contact name and an JOIN of two addresses and an JOIN of 3 phone numbers will look like:
<Contact>
  <Name>...</Name>
  <Address>...</Address>
  <Address>...</Address>
  <PhoneNumber>...</PhoneNumber>
  <PhoneNumber>...</PhoneNumber>
  <PhoneNumber>...</PhoneNumber>
</Contact>

If GUESS is supported then variables will be used to guess a field. This is mostly useful
for out of scope commands where a field is not recognized. Support for guess can help in giving a 
proper response for out of scope requests (such as giving a hint or an error message).

If CONTEXT LOOKUP is supported then the context will be used by the agent as a data source.
In this case the agent will use all elements with the agent's xml tag as data source.
For example assume that the following is part of the previous action of a Context:
<Name>
   <FirstName><![CDATA[Siamak]]></FirstName>
</Name>
<Name>
   <![CDATA[Babak]]>
</Name>
<Name>
   <![CDATA[Pegah]]>
</Name>
Then a Name agent will use 'Babak' and 'Pegah' (but not Siamak) as data and will try to match those to
the input. This is useful for claiming what has been guessed using the variable condition by 
this agent on a previous input. 

Currently the CONTEXT LOOKUP support is only for the previous action of the context.

If KEYWORD_ONLY_MATCH is supported then the agent will make a claim if a keyword is matched even if no field 
is matched.

If RECENCY is supported the down chain agents that have been actuated more recently will be
given higher priority. The recency of actuation is determined by examining the previous actuation 
in the context (tags in the previous actuation relative to the down chain of this agent - the tags 
should appear right Under a tag made by this agent). 

INTERPRETATION
--------------
More recently mentioned searchable objects will have more priority. So for example if the user asks for
"emails to john" and then asks for "..david" it will be assumed that 'david' is a TO field receipient (rather
than CC or BCC receipient) as TO has been mentioned in the previous input.
*/

/** What is the keyword that identifies this object? */
String keyword = this.tag;

/** Reference words that must be adjacent to the keyword */
Condition adjacentReference = 'this'|'that'|'those'|'the'|'these';
/** Explicit reference keywords */
Condition explicitReference = '';

/** What is the preposition for this object? (e.g. 'in' or 'at' are used for a place)*/
String preposition;
/** What is the priority associated with this object... priorities can be examined outside the agent network
    to reslove ambiguities */
String preference;

/** What is the role of this template/agent? This is going to be used as an XML attribute associated to the XML element created by this template*/
constant String type = 'object';

/** What groups does this object belongs to?<br>
    This property is used in hints. The value can be any comma seperated list.<br>
    Each item in the list will represent a group.<br>
    For example Restaurant groups= "outdoor, food & drink" <br>
*/
String groups;

/** The database name used for generating SQL 
 * @deprecated 
 */
String tableName = this.tag;

/** The database column name used for generating SQL 
 * @deprecated 
 */
String columnName = '';

/** The column name used for any claims made by the object itself (eg from the variable condition) 
 * @deprecated 
 */
String defaultColumnName = '';

/** Should the join be using the downchain agent as having the foreign key? 
 * @deprecated 
 */
Boolean downChainJoin = false;

/** Join column if using a downchain join 
 * @deprecated 
 */
String downChainColumn = '';

/** The database table primary key name used for generating SQL 
 * @deprecated 
 */
String primaryKey = 'ID';

/** These flags are used to set or reset certain features in the polcies created by this template*/

/** Should the policies support implicit matches? (that is when an object field is referenced in the input but the keyword used for
    that object is not referenced) */
Boolean implicitMatch = true;
/** Should the agent make a claim if a keyword is matched but no field is matched? */
Boolean supportKeywordOnlyMatch = true;
/** Should the policies support ambiguity? */
Boolean supportAmbiguity = true;
/** Should the agent use the context as a data source?  */
Boolean supportContextLookup = true;
/** Should the polcies referring to recently referenced actions get higher priority? */
Boolean supportRecency = false;
/** Should variables be used to guess the value of this field in the pattern: <i>variable</i> isValueOf */
Boolean supportLeftGuess = false;
/** Should variables be used to guess the value of this field in the pattern: equalsTo <i>variable</i> */
Boolean supportRightGuess = false;
/** Should variables be used to guess the value of this field in the pattern: beforeValue <i>variable</i> afterValue*/
Boolean supportMiddleGuess = false;
/** Should the policies support joining commands to eachother? (ORs and ANDs)*/
Boolean supportJoin = false;
/** The condition used to identify an OR join*/
Condition orKeyword = 'or';
/** The condition used to identify an AND join*/
Condition andKeyword = 'and';
/* What is the minimum number of tokens that should be used as a variable. <br>Used only if supportGuess is true */
Integer minVariableSize = 1; 
/* What is the maximum number of tokens that should be used as a variable. <br>Used only if supportGuess is true */
Integer maxVariableSize = 3; 
/* What is the minimum size of a non-noise token (in characters). Noise tokens will not be claimed as part of a variable. <br> Used only if supportGuess is true */
Integer minVariableNonNoiseTokenSize = 1; 
/* What is the file used to list noise words. Noise words will not be claimed as part of a variable. <br> Used only if supportGuess is true */
File variableNoiseFile = 'variable_noise.txt'; 

/** The condition used to match explicit claims on the object this agent is representing.<br>
    Should be a combination of any string literal, preposition, kwd and adjacentReference
  */
Condition equalsTo = [preposition] ~ (kwd|adjacentReference) ~ (['is'] ~ ['equal' ~ ['to']]|'isEqualTo'|'=');

/** The condition used to match explicit claims on the object this agent is representing.<br>
    Should be a combination of any string literal, kwd and adjacentReference
  */
Condition isValueOf = ('isValueOf' | ('is' ~ ['the'] ~ 'value of')) ~ (kwd|adjacentReference);

/** Condition that comes before a value in the condition: (beforeValue value afterValue)*/
Condition beforeValue = '';
/** condition that comes after a value in the condition: (beforeValue value afterValue)*/
Condition afterValue = '';

/** Should the agent filter unvaluable (potentially problematic) down chain agent claims?
  */
Boolean enableFilterDownChainClaims = true;

/** Should the agent filter unvaluable (potentially problematic) down chain agent claims?
  */
Boolean enableFilterDownChainAtomicSubclaims = true;

/** Should the agent filter unvalueable non-field down chain agent subclaims?
  */
Boolean enableFilterNonFieldSubclaims = true;

/** Should the agent filter non field down chain agent subclaims?
  */
Boolean enableFilterDownChainClaimsWithMoreRelations = true;
/** How should the value of this field be used to narrow down the previous input? <br>
    Valid values are: <i>add</i>, <i>addNew</i> and <i>replace</i> <br>
    If replace (which is the default if no values is associated with this property) then the 
    the old relation value will be removed when new relation value is added.<br>
    If add then the new relation value will be added along with the old relation value.<br>
    If addNew then a new command will be added and this relation will be part of the relation referenced in the new command (old command will be kept in the output as well)<p>

    Example:<br>
    for a pizza object the size and crust fields can be seen as fields that should always be replaced on followup (replace).<br>
    for example: <br>
    "small pizza"<br>
    "..large pizza"<br>
    you don't want to end up with a pizza which is both small and large<p>

    However you may decide that new toppings should always be added to old toppigs when you followup (add):<br>
    for example:<br>
    "pepperoni pizza"<br>
    "..ham"<br>
    you want to end up with a "pepperoni and ham pizza"<p>

    Then you may decide that the count for a pizza always means that a new order is coming (addNew):<br>
    "1 pepperoni pizza"<br>
    "..2 small ones"<br>
    "..and one large pizza"<br>
    in this case you want to end up with three orders for 5 pizzas (1 pepperoni, 2 small and one large)
*/    
String defaultSlotFilling;

/**
    By default this is not a single slot. But you can set this to true.
*/
Boolean singleSlot;

/* live interpretation table name - used for suggestion generation from this object */
String liveInterpretationTable;

preposition:
    this.preposition
    {attributes: 'private, atomic'}
    {action: ''}
;

/** Claims keywords used for this field */
kwd:
    this.keyword | /CONTEXT:KWD(this.tag)
    {attributes: 'private, atomic'}
    {action: addAttribute('explicit', 'true')}
;

/** Actuated when the user references this object without referencing any of its fields.
    Makes a claim only if either supportKeywordOnlyMatch is true or if this agent is part of a previous ambiguity.
    */
onlyKwd:
    this.supportKeywordOnlyMatch & ([preposition] ~ kwd) | <check('previous_ambiguity', this)> & ([preposition] ~ kwd)
    {attributes: 'private, atomic'}
    {priority: topicScope(this, this.supportRecency)}
    {action: com.dejima.core.nlp.text.action.ObjectActuation: 
         setTag(this.tag), setTableName(this.tableName), setColumnName(this.columnName), setDefaultColumnName(this.defaultColumnName), setDownChainJoin(this.downChainJoin), setDownChainColumn(this.downChainColumn), setPrimaryKey(this.primaryKey), addAttribute('type', this.type), addAttribute('groups', this.groups), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), kwd}
;

/** This policy is actuated when the user references this object using adjacent references (eg. "the", "this",...)  */
adjacentReferenceIndicator:
    (<exact> (this.adjacentReference))
    {attributes: 'private, atomic'}
    {action: addAttribute('reference', *)}
;

/** Adjacent references always come before the keyword (eg. "the contact", "this contact",...) */
adjacentReference:
     (adjacentReferenceIndicator ~ kwd)
    {attributes: 'private, atomic'}
    {action: adjacentReferenceIndicator, kwd}
;

/** Explicit references are used instead of the object keyword (eg. "it", "her", "him",...) */
explicitReference:
    <check('previous_action',this)> & (<exact> (this.explicitReference))
    {attributes: 'private, atomic'}
    {action: addAttribute('reference', *)}
;

/** This policy is actuated when the user references this field ony using an explicit references (eg. "it", "her", "him",...) or adjacent reference (eg. 'the contact') */
onlyReference:
    this.supportKeywordOnlyMatch & ([preposition] ~ (explicitReference|adjacentReference))
    {attributes: 'private, atomic'}
    {action: com.dejima.core.nlp.text.action.ObjectActuation: 
         setTag(this.tag), setTableName(this.tableName), setColumnName(this.columnName), setDefaultColumnName(this.defaultColumnName), setDownChainJoin(this.downChainJoin), setDownChainColumn(this.downChainColumn), setPrimaryKey(this.primaryKey), addAttribute('type', this.type), addAttribute('groups', this.groups), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), explicitReference, adjacentReference}
;

/** This policy claims any form of references (adjacent or explicit). this policy is actuated if the user references this object and some fields of this object (eg. 'find the contact with last name john') or references this object joined to some other objects (eg. 'find him or contact who lives in san jose')*/
reference: 
    this.supportKeywordOnlyMatch & ([preposition] ~ (adjacentReference | explicitReference))
    {attributes: 'private, atomic'}
    {action: adjacentReference, explicitReference}
;

beforeValue:
    this.beforeValue
    {attributes: 'private, atomic'}
;

afterValue:
    this.afterValue
    {attributes: 'private, atomic'}
;

equalsTo:
    this.equalsTo
    {attributes: 'private, atomic'}
;

isValueOf:
    this.isValueOf
    {attributes: 'private, atomic'}
;

/** want to give high priority to a topic, if any. If its not a topic, then recency is used, which 
 *  gives priority to recently discussed items  */
topic(this.children):
    this.children[.] - reference
    {attributes: 'private'}
    {priority: topicScope(this.children[.], this.supportRecency)}
    {action: this.children[.]}
;

/** There is a pattern here: the _field represent the slot, which may or may not be ambiguous with other slots. */
implicitField(this.children):
    topic(this.children[.]) | this.supportAmbiguity & (<mergeIfAmbiguous(topic(this.children[.]),topic(this.children[#]):op(,))>)
    {attributes: 'private'}
    {ambiguity action: com.dejima.core.nlp.text.action.EntityActuation:  
       setTag(this.ambiguityTag), topic(this.children)}
;

explicitField(this.children):
    equalsTo ~ implicitField(this.children[.]) | 
    [preposition] implicitField(this.children[.]) ~ isValueOf |
    beforeValue ~ implicitField(this.children[.]) ~ afterValue
    {priority: 10001}
    {attributes: 'private, atomic'}
    {action: equalsTo, isValueOf, beforeValue, afterValue, implicitField(this.children[.])}
;

field(this.children):
     implicitField(this.children[.]) | explicitField(this.children[.])
     {attributes: 'private'}
     {action: implicitField(this.children[.]) , explicitField(this.children[.])}
;

/** 
 * Handle joining different fields.
 */
fields:
    <merge(field(this.children):op(,))>
    {attributes: 'private'}
    {action: field(this.children)}
;


supportGuess:
    this.supportLeftGuess | this.supportRightGuess | this.supportMiddleGuess
    {attributes: 'private'}
;
   
/** Makes a guess on the value of the object (if the guess feature is supported) */
containsGuess:
    supportGuess & (
      (this.supportRightGuess & (equalsTo ?:(this.minVariableSize,this.maxVariableSize):this.minVariableNonNoiseTokenSize:this.variableNoiseFile)) |
      (this.supportLeftGuess & ([[preposition] ~ ['the']]  ?:(this.minVariableSize,this.maxVariableSize):this.minVariableNonNoiseTokenSize:this.variableNoiseFile isValueOf)) |
      (this.supportMiddleGuess & (beforeValue ?:(this.minVariableSize,this.maxVariableSize):this.minVariableNonNoiseTokenSize:this.variableNoiseFile afterValue)) )
    {attributes: 'private, atomic'}
    {action: equalsTo, isValueOf, beforeValue, afterValue, addCData(?)}
;

variableInQuotes:
    supportGuess & (('\'' ? '\'') | ('"' ? '"'))
    {attributes: 'private, atomic'}
    {action: '"',?,'"'}
;

/** Makes a guess on the exact value of the object (if the guess feature is supported). 
    The guess will be made only on words surrounded by quotes
  */
exactGuess:
    supportGuess & ((equalsTo ~ variableInQuotes) | ([preposition] ~ variableInQuotes ~ isValueOf))
    {attributes: 'private, atomic'}
    {action: equalsTo, isValueOf, addCData(variableInQuotes)}
;

objectCandidate:
    (fields)
    {attributes: 'private'}
    {action: fields}
;

explicitIndication:
    (explicitField(this.children))
    {attributes: 'private'}
;

explicitObject:
    <includes (explicitIndication)> objectCandidate |
    (equalsTo|isValueOf|reference) & (objectCandidate)
    {attributes: 'private'}
    {action: equalsTo, isValueOf, reference, objectCandidate}
;

implicitObject:
    (this.implicitMatch | <check('previous_action',this)>) & (objectCandidate - explicitObject)
    {attributes: 'private'}
    {action: objectCandidate}
;

/** only make a guess if there are no explicit matches
  */
guess:
    supportGuess & ([''] - explicitObject) & (containsGuess | exactGuess)
    {attributes: 'private, atomic'}
;

anObject:
    explicitObject | implicitObject | reference | guess
    {attributes: 'private'}
;

object:
    anObject
    {attributes: 'private'}
    {action: com.dejima.core.nlp.text.action.ObjectActuation: 
         setTag(this.tag), setTableName(this.tableName), setColumnName(this.columnName), setDefaultColumnName(this.defaultColumnName), setDownChainJoin(this.downChainJoin), setDownChainColumn(this.downChainColumn), setPrimaryKey(this.primaryKey), addAttribute('type', this.type), addAttribute('groups', this.groups), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), anObject}
;

andJoin:
    this.andKeyword
    {attributes: 'private, atomic'}
    {action:  
       addAttribute('join', 'and')}
;

orJoin:
    this.orKeyword
    {attributes: 'private, atomic'}
    {action:  
       addAttribute('join', 'or')}
;

joinOperation:
    orJoin | andJoin
    {attributes: 'private, atomic'}
;

joinedObject:
    this.supportJoin & (joinOperation ~ anObject)
    {attributes: 'private'}
    {action: com.dejima.core.nlp.text.action.ObjectActuation: 
         setTag(this.tag), setTableName(this.tableName), setColumnName(this.columnName), setDefaultColumnName(this.defaultColumnName), setDownChainJoin(this.downChainJoin), setDownChainColumn(this.downChainColumn), setPrimaryKey(this.primaryKey), addAttribute('type', this.type), addAttribute('groups', this.groups), addAttribute('preference', this.preference), setDefaultSlotFilling(this.defaultSlotFilling), setSingleSlot(this.singleSlot), joinOperation, anObject}
;

joinedObjects:
    this.supportJoin & (object ~^ joinedObject)
    {attributes: 'private'}
;

main:
    (joinedObjects | object)+ | onlyReference | onlyKwd
;
